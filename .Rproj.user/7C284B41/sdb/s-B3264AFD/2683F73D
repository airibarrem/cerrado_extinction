{
    "contents" : "# LNAE: SPATIAL-ALLOCATION FUNCTIONS\n#\n# Created: Dec. 2014\n# Author: Alvaro Iribarrem (IIS-Rio)\n#\n#\n#rm(list=ls())\n\nheaviside = function(x){stepfun(0,c(0,1))(x)}\n\nrcompose = function(x, bgx){\n  # read input raster\n  rast = raster(x)\n  # remove NA values from input raster\n  rast[is.na(rast)]=0\n  # mask input raster using the background one\n  rast = rast + bgx\n  return(rast)\n}\n\n# Used to combine land-use (x) and road (y) time to traverse costs\n# for later use with ArcGIS tool Cost Distance\nrcombine = function(x, y, eps=0.1, ceil=1.e12){\n  y[y<eps]=ceil\n  return(min(x,y,na.rm=T))\n}\n\ncond.area = function(x, xcond, convert.ha=TRUE, px.val=F){\n  # Returns an approximate area of pixels in \"x\" that satisfy \"xcond\" condition.\n  # \"xcond\" must be a logical raster (px values either 0 or 1).\n  zone.count = 0\n  zone.res = zonal(x,xcond,fun=function(x, na.rm){ if(na.rm){length(na.omit(x))}\n                                                   else{length(x)}})\n  if(length(zone.res[,1]) > 1){zone.count = zone.res[[2,2]]}\n  px.a = mean(values(area(x)))\n  res = px.a*zone.count\n  if (convert.ha==TRUE){res = res*100}\n  if (px.val == T){\n    print(paste(\"Px count:\",zone.count))\n    res = zone.count}\n  return(res)\n}\n\nallocate.area = function(x,bgd,area,init.value=0, prec=1e-3, verbose=F){\n  # allocates the input amount of area according to a priority raster x\n  print(\"Running allocate.area function...\")\n  step=0.1\n  vtry=init.value\n  atry = cond.area(x,x>vtry)\n  pdiff = abs((area-atry)/area)\n  while (pdiff > prec){\n    if (vtry+step>=1-prec){step=0.1*step}\n    vtry=vtry+step\n    atry.l = atry\n    atry = cond.area(x,x>vtry)\n    #if (abs(atry-atry.l)<1.e-8){\n    #   print(paste(\"!!! area diff == \",abs(htry-htry.l),\"!!!\"))\n    #  res = sampleRandom(x>vtry,cond.area(x,x>vtry,px.val=T),asRaster=T)\n    #   res[is.na(res)]=0\n    #   res = (res/res) + bgd\n    #   return(res)}\n    if (abs((area-atry)/area) > pdiff){step=-0.1*step}\n    pdiff = abs((area-atry)/area)\n    if (verbose==T){print(paste(vtry, pdiff))}\n  }\n  return(x>vtry)\n}\n\nallocate.herd = function(x,herd,prd.ras,bgd,px.area,init.value=0, prec=1e-3,\n                         verbose=F){\n  print(\"Running allocate.herd function...\")\n  step=0.1\n  vtry=init.value\n  htry = sum(values(prd.ras*(x>vtry)),na.rm=T)*px.area\n  pdiff = abs((herd-htry)/herd)\n  while (pdiff > prec){\n    if (vtry+step>=1-prec){step=0.1*step}\n    vtry=vtry+step\n    rtry = (x>vtry)/(x>vtry)\n    htry.l = htry\n    htry = sum(values(prd.ras*rtry),na.rm=T)*px.area\n         if (abs(htry-htry.l)<1.e-8){\n           print(paste(\"!!! herd diff == \",abs(htry-htry.l),\"!!!\"))\n    #res = sampleRandom(x>(vtry-step),cond.area(x,x>vtry,px.val=T),asRaster=T)\n    #       res[is.na(res)]=0\n    #       res = (res/res) + bgd\n    #       plot(res)\n    #Sys.sleep(2)\n           return(x>vtry-step)}\n    if (abs((herd-htry)/herd) > pdiff){step=-0.1*step}\n    pdiff = abs((herd-htry)/herd)\n    if (verbose==T){print(paste(vtry, pdiff, abs(htry-htry.l)))}\n  }\n  return(x>vtry)\n}\n\ninten.rate = function(SCN.hrd, SCN.prd, pot.hrd, ctl.ras, px.area, prec=1.e-3,\n                      verbose=F){\n  step=0.01\n  mun.try = SCN.prd\n  hrd.try = sum(values(mun.try*ctl.ras),na.rm=T)*px.area\n  pdiff = abs(SCN.hrd - hrd.try) / SCN.hrd\n  while (pdiff > prec){\n    mun.try = mun.try + (step * SCN.prd)\n    mun.try = mun.try*((mun.try - pot.hrd)<0) + pot.hrd*((mun.try - pot.hrd)>0)\n    plot(mun.try, main=\"Stocking rate (heads/ha)\")\n    hrd.try = sum(values(mun.try*ctl.ras),na.rm=T)*px.area\n    if (abs((SCN.hrd-hrd.try)/SCN.hrd) > pdiff){step=-0.1*step}\n    pdiff = abs(SCN.hrd-hrd.try)/SCN.hrd\n    if (verbose==T){print(paste(hrd.try, pdiff))}\n  }  \n  return(mun.try)\n}\n\nallocated.xs = function(a.try, f.now, munmask, xs.thr=0.5){\n  if (xs.thr>1){xs.thr = xs.thr/100}\n  # Comuptes area of original forest that is inside raster munmask\n  a.for = cond.area(f.now,f.now*(munmask))\n  # Computes threshold area of the municipality\n  a.thr = cond.area(munmask,munmask) * xs.thr\n  # Computes available area for legal deforestation\n  a.leg = a.for - a.thr\n  # Computes allocated excess\n  xs = a.try\n  if (a.leg > 0){xs = (a.try - a.leg) * heaviside(a.try - a.leg)} \n  return(xs)\n}",
    "created" : 1458757055598.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2306588962",
    "id" : "2683F73D",
    "lastKnownWriteTime" : 1441917009,
    "path" : "~/IIS_PROJECTS/Moore/Zonation_AF/sp_fun.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}