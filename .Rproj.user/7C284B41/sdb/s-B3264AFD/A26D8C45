{
    "contents" : "# SCENARIOS WRAPPER\n\nCF.scen = function(fsz.lo = 2, fsz.hi = 3.5, fsz.nstep = 100, fsz.fun = tens,\n                   avg.SR = 1.5, systems = c(1,2,3), FL.type = c(1,2,3),\n                   FL.shares=c(0,20), int.shares=c(0,20), icl.shares=c(0,20),\n                   for.shares = c(0,80), rest.types = c(1,2),\n                   MC.runs = 1000, MC.sd = c(10,10,10,10),\n                   sf.on = T, cores = 3,\n                   MGT.filename = 'interface_MBE-v2', LOC.filename = MGT.filename,\n                   file.ext = \".xlsx\", IN.path=getwd(),\n                   MGT.sheet=\"DADOS_FAZENDA\", LOC.sheet=\"PARAMETROS_LOCAIS\"){\n  \n  ##############################################################################\n  # Description\n  # Wrapper to define scenarios, call CF.gen for each of them, changing the\n  # pertinent parameters and storing the corresponding economic indicators.\n  #\n  # Inputs:\n  # fsz.lo        farm-size interval lower boundary [ha]\n  # fsz.hi        farm-size interval higher boundary [ha]\n  # fsz.nstep     farm-size interval number of steps\n  # fsz.fun       mean = linear steps | tens = order of magnitude steps\n  # avg.SR        average stocking rate [heads/ha]\n  #\n  # systems       cattle systems to be included (1=breed, 2=fatten, 3=complete)\n  # FL.type       Feeding-Lot types to be included (1=none, 2=partial, 3=full)\n  # FL.shares     Feeding-lot capacity as a percentage of initial herd size\n  #\n  # int.shares    intensified pasture area shares to be included\n  # icl.shares    integrated crop-livestock area shares to be included\n  # for.shares    forest restoration area share goals to be included\n  #\n  # rest.types    forest restoration types to be included (see farm.def.R)\n  #\n  # MC.runs       number of runs per Monte Carlo simulation\n  # MC.sd         Standard deviations for c(Prices, Costs, Stk. Rates, Interest)\n  #\n  # sf.on         logical: turns on snowfall (sf) parallel processing\n  # cores         argument passed to snowfall call: number of cores for parallel\n  ##############################################################################\n  \n  source('./farm.fun.R')\n\n  start = Sys.time()\n  \n  IP = read.farm(filename = MGT.filename, file.ext = file.ext,\n                 filepath = IN.path, XL.sheet = MGT.sheet) \n  \n  local.par = read.loc (filename = LOC.filename, file.ext = file.ext,\n                        filepath = IN.path, XL.sheet = LOC.sheet)\n       \n  farm.sizes = as.numeric(\n    lapply(fsz.lo + (fsz.hi-fsz.lo)*(0:(fsz.nstep-1))/(fsz.nstep-1), fsz.fun))\n  \n  if (fsz.nstep == 1) {\n    farm.sizes = as.numeric(lapply((fsz.lo + fsz.hi)/2,fsz.fun))\n    }\n  \n  # List of parameters to be passed to snowfall call:\n  sf.list = list()\n  \n  # Object to receive result from snowfall call:\n  res = data.frame((rep(0,11)), row.names=scen.rows)\n      \n  for (i in seq(along=farm.sizes)){\n  for (j in systems){\n  for (l in seq(along=int.shares)){\n  for (m in seq(along=icl.shares)){\n  for (n in seq(along=for.shares)){\n  for (o in seq(along=rest.types)){\n  for (p in FL.type){\n  for (q in seq(along=FL.shares)){  \n  for (k in 1:MC.runs){\n    \n    IP.run = IP\n    local.par.run = local.par\n    \n    # Updating farm sizes\n    IP.run[[8]]$Area = (IP[[8]]$Area / sum(IP[[8]]$Area)) * farm.sizes[i]\n\n    # Updating cattle-ranching system\n    IP.run[[11]] = ctl.sys.names[j]\n\n    # Updating initial cattle\n    IP.run[[6]] = h.gen(as.numeric(farm.sizes[i] * avg.SR), system = ctl.sys.names[j])\n\n    # Updating feeding-lot information\n    IP.run[[16]] = as.numeric(p)\n    IP.run[[17]] = as.numeric( farm.sizes[i] * avg.SR * (FL.shares[q]/100) )\n    \n    # Updating initial land-use-share goals\n    IP.run[[12]] = icl.shares[m]\n    IP.run[[13]] = int.shares[l]\n    IP.run[[14]] = for.shares[n]\n    IP.run[[21]] = rest.names[o+1]\n\n    # Updating MC run parameters\n    local.par.run[[9]][1,] = MC.sd\n\n    # Creating list of parameters for the current run\n    run.list = list(farm.sizes[i], ctl.sys.names[j], fed.sys.names[p],\n                    IP.run[[17]], k, int.shares[l],\n                    icl.shares[m], for.shares[n], rest.names[o+1])\n\n    # Creating sf.list entry for the run\n    in.par = list(IP.run, local.par.run, run.list)\n        \n    # Updating sf.list\n    sf.list[length(sf.list)+1] = list(in.par)\n  }}}}}}}}}\n\n  save('sf.list', file='sf.list')\n  \n  # Letting snowfall do its magic\n  sfInit(parallel = sf.on, cpus = cores, type = 'SOCK')\n    res = sfLapply(sf.list, CF.gen, MC.out=(MC.runs>1), silent=F)\n  sfStop()\n\n  print(Sys.time()-start)\n  \n  if (MC.runs>1){return(as.numeric(res))}\n  \n  # Organizing the result from the snowfall call in a data.frame structure\n  res = data.frame(matrix(unlist(res),nrow=length(scen.rows)),\n                   row.names=scen.rows, stringsAsFactors=F)\n  return(res)\n}",
    "created" : 1458846875761.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3635723826",
    "id" : "A26D8C45",
    "lastKnownWriteTime" : 1458583369,
    "path" : "C:/Users/Alvaro/Google Drive/farm_model/CF.scen.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}