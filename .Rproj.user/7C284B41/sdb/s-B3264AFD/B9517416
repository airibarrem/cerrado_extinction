{
    "contents" : "# LNAE: SPATIAL ALLOCATION FOR THE ALTA FLORESTA CASE\n#\n# Created: Dec. 2014\n# Author: Alvaro Iribarrem (IIS-Rio)\n#\n#\n#rm(list=ls())\n\nsource('./rast_norm.R')\nsource('./sp_fun.R')\nsource('./fc_comply.R')\n\n# Computing cluster area background raster\nbgd = raster(\"./in/Municipios.tif\")\nbgd = bgd/bgd\nbgd[bgd>0]=0\n\n\n# Cluster municipalities\nmun.ras = rcompose(\"./in/Municipios.tif\",bgd)\nmun.nam = c(\"Alta Floresta\", \"Apiacás\", \"Carlinda\", \"Nova Bandeirantes\",\n            \"Paranaíta\", \"Nova Monte Verde\")\n\n# Computing the average pixel area [ha]\npx.area = mean(values(area(bgd))) * 100\n\n# Different pasture types\npast.r = rcompose(\"./mod/norm_Pasto_sujo_Cortado.tif\", bgd)\npast.d = rcompose(\"./mod/norm_Pasto_degradado_Cortado.tif\", bgd)\npast.l = rcompose(\"./mod/norm_Pasto_limpo_Cortado.tif\", bgd)\npast.t = past.r + past.d + past.l\n\n# Cluster present stocking rate per municipality [heads/ha]\nstk.zero = c(1.59,1.11,1.28,1.51,1.87,1.48)\n\n# Cluster projected stocking rate per municipality [heads/ha]\nmun.stk = c(2.19, 1.94, 1.67, 2.48, 2.73, 2.01)\nmun.stk = mun.stk\n\n# Projected stocking rate map\nmun.prd = bgd\nfor (i in 1:length(mun.nam)){\n  # Pasture-type stocking rate modifiers w.r.t. \"limpo\" type\n  r.m = 0.15\n  d.m = 0.15\n  # Pasture-type areas in municipality i\n  r.a = cond.area(mun.ras==i,(mun.ras==i)*past.r)\n  d.a = cond.area(mun.ras==i,(mun.ras==i)*past.d)\n  l.a = cond.area(mun.ras==i,(mun.ras==i)*past.l)\n  t.a = r.a + d.a + l.a\n  # Pasture-type stocking rates in municipality i  \n  p.l = mun.stk[i]*t.a / (l.a + d.m*d.a + r.m*r.a)\n  p.r = r.m * p.l\n  p.d = d.m * p.l\n  # Updates stocking rate (mun.ras) map\n  mun.prd = mun.prd + p.l*past.l*(mun.ras==i) + p.r*past.r*(mun.ras==i) +\n    p.d*past.d*(mun.ras==i) + mun.stk[i]*((1+bgd-past.t)*(mun.ras==i))\n}  \n\n# Normalized potential productivity maps\npot.ctl = rcompose(\"./mod/norm_Pot_Pasto_Cortado.tif\", bgd)\npot.soy = rcompose(\"./mod/norm_Pot_Soja_Cortado.tif\", bgd)\n\n# Natural units (heads/ha) potential stocking rate map\npot.hrd = rcompose(\"./in/Pot_Pasto_Cortado.tif\", bgd)/0.7\n\n# Land covers\nfor.cov = rcompose(\"./mod/norm_Florestas_Cortado.tif\", bgd)\noth.cov = rcompose(\"./mod/norm_Outros_usos_Cortado.tif\", bgd)\ncun.cov = rcompose(\"./mod/norm_UCs_MAF_SIR.tif\", bgd)\n\n# Distance to processing units\ndis.cpu = raster(\"./in/costdis_ctl_2.tif\")\ndis.cpu = setExtent(dis.cpu,extent(bgd))\ndis.spu = raster(\"./in/costdis_soy_3.tif\")\ndis.spu = setExtent(dis.spu,extent(bgd))\n\n# Normalize distance layers\ndis.cpu = dis.cpu/max(values(dis.cpu),na.rm=T)\ndis.spu = dis.spu/max(values(dis.spu),na.rm=T)\n\n# Distance to pastures (any type)\ndis.pas = rcompose(\"./mod/norm_Dist_Pasto_total_Cortado.tif\", bgd)\n\n# Carbon stock\nc.stk = raster(\"./in/Carbono_Microrregiao_SIR.tif\")\nc.stk = resample(c.stk, dis.pas)\n\n\n# Building the normalized Soy prioritization layer\n soy.place = function(SD=F){\n   res = 10 + 0.1*pot.soy - 28.6*dis.spu - 100*(for.cov+oth.cov+cun.cov)\n   if (SD==T){\n     res = 10 + 0.1*pot.soy + (past.d + past.r) - 28.6*dis.spu -\n       100*(for.cov+oth.cov+cun.cov)\n   }\n   res[res<0]=0\n   res = res/max(values(res),na.rm=T)\n   return(res)\n }\n#soy.place = 10 + 0.1*pot.soy - 28.6*dis.spu - 100*(for.cov+oth.cov+cun.cov)\n#soy.place[soy.place<0]=0\n#soy.place = soy.place/max(values(soy.place),na.rm=T)\n\n# Saving rasters relevant to econometric parameterization\nwrite.csv2(data.frame(values(for.cov)),\"./out/forcov.csv\", row.names=F)\nwrite.csv2(data.frame(values(pot.ctl)),\"./out/potctl.csv\", row.names=F)\nwrite.csv2(data.frame(values(pot.soy)),\"./out/potsoy.csv\", row.names=F)\nwrite.csv2(data.frame(values(dis.cpu)),\"./out/disctl.csv\", row.names=F)\nwrite.csv2(data.frame(values(dis.spu)),\"./out/dissoy.csv\", row.names=F)\n\n\n# Allocating Soy area grow according to its prioritization layer\nsoy.grw = 201000\nBAU.soy = allocate.area(x=soy.place(),area=soy.grw,bgd=bgd,init.value=0,\n                        verbose=F)\n#LNAE.soy = allocate.area(x=soy.place(SD=T),area=soy.grw,bgd=bgd,init.value=0,\n#                         verbose=F)\nLNAE.soy = BAU.soy\n\n# Building the normalized Cattle-ranching priorization layer\n#ctl.place = pot.ctl - 2*dis.pas -0.3*dis.cpu - 100*(past.t+oth.cov+cun.cov)\nctl.place = 10 + 0.1*pot.ctl - 28.6*dis.cpu - 100*(past.t+oth.cov+cun.cov)\nctl.place[ctl.place<0]=0\nctl.place = ctl.place/max(values(ctl.place),na.rm=T)\n\n\n# Present herd size [heads]\nNOW.hrd = 2626995\n\n# Projected herd size (2030) [heads]\n#SCN.hrd = 3781983\nSCN.hrd = NOW.hrd * 1.23\n\n# Projected herd displaced by soy (2030) [heads]\nctl.dsp = sum(values(mun.prd*BAU.soy),na.rm=T)*px.area #soy-displaced herd\n\n# Projected additional herd size to be allocated\nBAU.grw = SCN.hrd - sum(values(mun.prd*(past.t-BAU.soy)*px.area),na.rm=T)\nLNAE.grw = SCN.hrd - sum(values(mun.prd*(past.t-LNAE.soy)*px.area),na.rm=T)\n\n#BAU.ctl = fc.comply(herd=ctl.grw, p.ras=ctl.place, p.now=past.t, p.pot=pot.ctl,\n#                    f.now=for.cov, s.scn=BAU.soy, m.ras=mun.ras, m.prd=mun.prd,\n#                    bgd=bgd, m.nam=mun.nam, px.area=px.area)\n\n\n# Allocating cattle-ranching area growth according to its priorization layer\nBAU.ctl = allocate.herd(x=ctl.place,prd.ras=mun.prd,bgd=bgd,herd=BAU.grw,\n                        px.area=px.area,verbose=F)\nBAU.ctl = BAU.ctl/BAU.ctl\nBAU.ctl[is.na(BAU.ctl)]=0\nBAU.ctl = BAU.ctl + (past.t - BAU.soy) + bgd\n\nLNAE.ctl = past.t - LNAE.soy + bgd\n\nFCC.ctl = fc.comply(herd=BAU.grw, p.ras=ctl.place, p.pot=pot.hrd, p.now=past.t,\n                    f.now=for.cov, f.lrm=cun.cov, s.scn=BAU.soy, m.ras=mun.ras,\n                    m.prd=mun.prd, m.nam=mun.nam, px.area=px.area, bgd=bgd,\n                    fc.thr=0.8, ival=0, prec=1.e-3)\nFCC.ctl = FCC.ctl/FCC.ctl\nFCC.ctl[is.na(FCC.ctl)]=0\nFCC.ctl = FCC.ctl + (past.t - BAU.soy) + bgd\n\n\n# Computing new forest cover under BAU and FCC scenario\nBAU.for = for.cov - (BAU.ctl+BAU.soy)\nBAU.for[BAU.for<0]=0\n\nFCC.for = for.cov - (FCC.ctl+BAU.soy)\nFCC.for[FCC.for<0]=0\n\n\n# Computing new other uses cover under BAU and FCC scenario\nBAU.oth = oth.cov + past.t - (BAU.ctl + BAU.soy + BAU.for)\nBAU.oth[BAU.oth<0]=0\n\nFCC.oth = oth.cov + past.t - (FCC.ctl + BAU.soy + FCC.for)\nFCC.oth[FCC.oth<0]=0\n\n\n# Computing land-use mosaics for each scenario\nNOW.mos = past.t + 4*for.cov +3*oth.cov\nBAU.mos = 2*BAU.soy + BAU.ctl + 4*BAU.for + 3*oth.cov\nFCC.mos = 2*BAU.soy + FCC.ctl + 4*FCC.for + 3*oth.cov\nLNAE.mos = 2*LNAE.soy + LNAE.ctl + 4*for.cov + 3*oth.cov\n\nwriteRaster(NOW.mos, \"./out/NOWmos.tif\", overwrite=T)\nwriteRaster(BAU.mos, \"./out/BAUmos.tif\", overwrite=T)\nwriteRaster(FCC.mos, \"./out/FCCmos.tif\", overwrite=T)\nwriteRaster(LNAE.mos, \"./out/LNAEmos.tif\", overwrite=T)\n\nwriteRaster(NOW.mos, \"./out/NOWmos.asc\", overwrite=T)\nwriteRaster(BAU.mos, \"./out/BAUmos.asc\", overwrite=T)\nwriteRaster(FCC.mos, \"./out/FCCmos.asc\", overwrite=T)\nwriteRaster(LNAE.mos, \"./out/LNAEmos.asc\", overwrite=T)\n\n\n# Computing total deforestation under BAU and FCC scenarios\nprint('***')\nBAU.defor = cond.area(for.cov,for.cov)-cond.area(BAU.for,BAU.for)\nFCC.defor = cond.area(for.cov,for.cov)-cond.area(FCC.for,FCC.for)\nprint(paste(\"Desmatamento total (BAU):\", round(BAU.defor),\"ha\"))\nprint(paste(\"Desmatamento total (FCC):\", round(FCC.defor),\"ha\"))\n\n# Computing total carbon emissions from deforestation\nHIc.area = sum(values((for.cov-BAU.for)*(c.stk>100)),na.rm=T)*px.area\nHIc.stk = sum(values((for.cov-BAU.for)*(c.stk>100)*c.stk),na.rm=T)*px.area\nc.avg = HIc.stk / HIc.area\nc.emit = sum(values((for.cov-BAU.for)*(c.stk>100)*c.avg), na.rm=T)*px.area\nprint(paste(\"Total de carbono emitido com o desmatamento:\", round(c.emit/1.e6),\n            \"MTon.\"))\n\n# Computing value for avoided carbon loss\nc.val = 5 # [US$/Ton. of CO2]\nus.to.r = 2.5 # US$ to R$ conversion\nREDD.val = c.emit * 44/12 * c.val * us.to.r\nprint(paste(\"Total de pagamento por emissão evitada: R$\", round(REDD.val)))\n\n# Herd size allocatable to LNAE pasture area, following projected stocking rates\ninten.r = 0\nmun.try = mun.prd + inten.r\nhrd.try = sum(values(mun.try*LNAE.ctl),na.rm=T)*px.area\n\n# Intensification rate needed to achieve LNAE\ninten.ras = inten.rate(SCN.hrd=SCN.hrd, SCN.prd=mun.prd, pot.hrd=pot.hrd,\n                       ctl.ras=LNAE.ctl, px.area=px.area, prec=1.e-4)\n\n# Intensification rate averaged per municipality\ninten.avg = zonal(inten.ras,mun.ras,fun=mean)[,2]\n\n# Initiating area-to-be-intensified vector:\nA.i.LNAE = c()\n\nprint('***')\nprint(paste(paste(\"FC% NOW\",\"FC% BAU \", sep=\"  ->  \"),\"LNAE stocking rate\",\n            sep=\"  |  \"))\nfor (i in 1:6){\n  # Total area to be intensified\n  # LNAE report, 27/Aug/2014, slide 47 ===> ESSA EQ. N SE APLICA NESSE CASO !!!\n  A.zero = cond.area(past.t,past.t*(mun.ras==i))\n  A.BAU =  cond.area(BAU.ctl, BAU.ctl*(mun.ras==i))# - cond.area(BAU.soy, BAU.soy*(mun.ras==i))\n  A.LNAE =  cond.area(LNAE.ctl, LNAE.ctl*(mun.ras==i))# - cond.area(BAU.soy, BAU.soy*(mun.ras==i))\n  p.zero = stk.zero[i]\n  p.BAU = mun.stk[i]\n  #p.BAU = s.farm*p.zero\n  p.LNAE = inten.avg[i]\n  #p.LNAE = s.farm*p.zero\n  #A.farm = 0.5 # relative-to-total area of the farm to be intensified\n  #A.farm = 0.2\n  c.i = 3.5\n  c.b = p.BAU / p.zero\n  #s.farm = 2.55/1.54   # relative-to-initial stocking rate gain of the whole farm, given a.farm\n  #s.farm = 1.7/1.54\n  dem.incr = SCN.hrd / NOW.hrd\n  #A.i.BAU = append(A.i.BAU, (A.farm/(s.farm-1))*(p.BAU/p.zero - 1)*A.BAU)\n  A.i.LNAE = append(A.i.LNAE, (p.LNAE/p.zero-c.b)/(c.i-c.b)*A.LNAE)\n  \n  print(paste0(format(cond.area(for.cov,for.cov*(mun.ras==i))/cond.area(mun.ras==i,mun.ras==i)*100,\n                      nsmall=1, digits=1), \"     ->  \",\n               format(cond.area(BAU.for,BAU.for*(mun.ras==i))/cond.area(mun.ras==i,mun.ras==i)*100,\n                      nsmall=1, digits=1), \" \", \"     |  \",\n               format(inten.avg[i], nsmall=2, digits=2), \"  \",\n               paste0(\"(\",mun.nam[i],\")\")\n  ))\n}\n\n# Total cost of intensification\nprint('***')\narea.cost = 2400 # [BRL/ha]\nmnt.cost = 450   # [BRL/ha/yr]\ncost.LNAE = sum(A.i.LNAE) * area.cost\nprint(paste(\"Custo total de aumento da lotação no LNAE: R$\", round(cost.LNAE)))\nmin.REDD = c.val*(cost.LNAE)/REDD.val\nprint(paste(\"Valor mínimo da ton. CO2 para financiar intensificaçao LNAE: US$\",\n            format(min.REDD,nsmall=2,digits=2)))\n\n\n# Total input needed\nprint('***')\narea.cal = 3 # [Ton/ha]\ncal.LNAE = sum(A.i.LNAE) * area.cal\nprint(paste(\"Demanda de calcário para aumento de lotação no LNAE:\",\n            format(cal.LNAE/1.e3, nsmall=2, digits=2), \"kTon.\"))\n\n# Increase in yearly demand of inputs\nprint('***')\narea.cal.yr = 0.5 #[Ton/ha/yr]\ncal.yr.LNAE = sum(A.i.LNAE) * area.cal.yr\nprint(paste(\"Aumento da demanda de calcário no LNAE:\",\n            format(cal.yr.LNAE/1.e3, nsmall=2, digits=2), \"kTon./ano\"))\narea.NPK.yr = 0.75 #[Ton/ha/yr]\nNPK.yr.LNAE = sum(A.i.LNAE) * area.NPK.yr\nprint(paste(\"Aumento da demanda de adubo (NPK) no LNAE:\",\n            format(NPK.yr.LNAE/1.e3, nsmall=2, digits=2), \"kTon./ano\"))\n\n\n# Visualizing land-use scenarios\npar(mfrow=c(2,2))\nplot(NOW.mos, main=\"Present land-use (2010)\")\nplot(BAU.mos, main=\"BAU projected land-use (2030)\")\nplot(FCC.mos, main=\"FC-compliance projected land-use (2030)\")\nplot(LNAE.mos, main=\"LNAE projected land-use (2030)\")\npar(mfrow=c(1,1))\n\n\n# Saving output rasters\nwriteRaster(BAU.soy, \"./out/BAUsoy.tif\", overwrite=T)\nwriteRaster(LNAE.soy, \"./out/LNAEsoy.tif\", overwrite=T)\nwriteRaster(mun.prd*past.t, \"./out/munprd.tif\", overwrite=T)\nwriteRaster(inten.ras*past.t, \"./out/inten.tif\", overwrite=T)\nwriteRaster(for.cov, \"./out/forcov.tif\", overwrite=T)\nwriteRaster(BAU.for, \"./out/BAUfor.tif\", overwrite=T)",
    "created" : 1458757049013.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1702067218",
    "id" : "B9517416",
    "lastKnownWriteTime" : 1443465895,
    "path" : "~/IIS_PROJECTS/Moore/Zonation_AF/sp_plan.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}